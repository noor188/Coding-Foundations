(require 2htdp/image)
(require 2htdp/universe)

;; Make it rain where ever we want

;; =================
;; Constants:

(define HEIGHT 300)
(define WIDTH  600)
(define MTS    (empty-scene WIDTH HEIGHT))
(define DROP-IMG (overlay/offset
                  (triangle 30 "solid" "light blue" )
                  0 17
                  (circle 15 "solid" "light blue")))


;; =================
;; Data definitions:

(define-struct drop (x y))
;; Drop is (make-drop Number Number)
;; interp. a drop at position x, y

(define DROP-1 (make-drop (/ WIDTH 2) (/ HEIGHT 2) ))
(define DROP-2 (make-drop 100          200))
#;
(define (fn-for-drop d)
  (... (drop-x d)(drop-y d)))

;; ListOfDrop os one of:
;; - empty
;; - (cons Drop ListOfDrop)
;; interp. a list of drops

(define LOD-1 empty)
(define LOD-2 (cons DROP-1 empty))
(define LOD-3 (cons DROP-2 LOD-2))
#;
(define (fn-for-LOD lod)
  (cond [(empty? lod) (...)]
        [ else
          (... (fn-for-drop(first lod))      ; Drop
               (fn-for-LOD(rest lod)))]))   ; ListOfDrop

;; =================
;; Functions:

;; ListOfDrop -> ListOfDrop
;; start the world with (main empty)
;; 
(define (main lod)
  (big-bang lod                  ; ListOfDrop
    (on-tick   next-drop)        ; ListOfDrop -> ListOfDrop
    (to-draw   draw-drop)        ; ListOfDrop -> Image
    (on-mouse  mouse-handler)))  ; ListOfDrop Integer Integer MouseEvent -> ListOfDrop
       
;; ListOfDrop -> ListOfDrop
;; produce the next drops position in the list by adding 1 to drop-y and removes excess drops (drops reach the bottom of the screen) out of the screen 
(check-expect (next-drop LOD-1) empty)
(check-expect (next-drop (cons (make-drop (/ HEIGHT 2) (/ WIDTH 2)) empty)) (cons (make-drop (/ HEIGHT 2) (+ (/ WIDTH 2) 1)) empty))
(check-expect (next-drop (cons (make-drop 100 200) (cons (make-drop (/ HEIGHT 2) (/ WIDTH 2)) empty))) (cons (make-drop 100 (+ 200 1)) (cons (make-drop (/ HEIGHT 2) (+(/ WIDTH 2) 1)) empty)))
;(define (next-drop lod) lod); stub

(define (next-drop lod)
  (cond [(empty? lod) empty]
        [ else
          (cons (update-y(first lod))       ; Drop
                (next-drop(rest lod)))]))   ; ListOfDrop

;; Drop -> Drop
;; Produce the next drop by adding 1 to y drop postion
(check-expect (update-y (make-drop 100 200)) (make-drop 100 (+ 200 1)))
(check-expect (update-y (make-drop   0   0)) (make-drop   0 (+   0 1)))
;(define(update-y d) (make-drop 100 200)); stub

(define (update-y d)
  (make-drop (drop-x d)(+ (drop-y d) 1)))

;; ListOfDrop -> Image
;; render all drops into it's (x,y) position in the MTS
(check-expect (draw-drop empty) MTS)
(check-expect (draw-drop (cons (make-drop (/ WIDTH 2)(/ HEIGHT 2) ) empty)) (place-image
                                                                             DROP-IMG
                                                                             (/ WIDTH 2) (/ HEIGHT 2)
                                                                             MTS))
(check-expect (draw-drop (cons (make-drop 100 200) (cons (make-drop (/ WIDTH 2)(/ HEIGHT 2) ) empty))) (place-image                                                                                                        
                                                                                                        DROP-IMG
                                                                                                        100 200                                                                                                        
                                                                                                        (place-image
                                                                                                         DROP-IMG
                                                                                                         (/ WIDTH 2) (/ HEIGHT 2)                                                                                                         
                                                                                                         MTS)))
;(define (draw-drop lod) MTS); stub

(define (draw-drop lod)
  (cond [(empty? lod) MTS]
        [ else
          (place-image DROP-IMG
                       (drop-x (first lod))(drop-y (first lod))                       
                       (draw-drop  (rest lod)))]))   ; ListOfDrop

;; ListOfDrop Integer Integer MouseEvent -> ListOfDrop
;; Creates a new drop at mouse (x,y) position and adds it to ListOfDrop
(check-expect (mouse-handler empty 300 100 "button-down") (cons (make-drop 300 100) empty))
(check-expect (mouse-handler empty 300 100 "enter"      ) empty)
(check-expect (mouse-handler (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2) ) empty) 200 50 "button-down") (cons (make-drop 200 50) (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2) ) empty)))
(check-expect (mouse-handler (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2) ) empty) 200 50 "enter") (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2) ) empty))
(check-expect (mouse-handler (cons (make-drop 100 200) (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2) ) empty)) 150 150 "button-down") (cons (make-drop 150 150) (cons (make-drop 100 200) (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2) ) empty))))
(check-expect (mouse-handler (cons (make-drop 100 200) (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2) ) empty)) 150 150 "enter"      ) (cons (make-drop 100 200) (cons (make-drop (/ WIDTH 2) (/ HEIGHT 2) ) empty)))
;(define (mouse-handler lod x y me) lod);

(define (mouse-handler lod x y me)
  (cond [(mouse=? me "button-down") (cons (make-drop x y) lod)]
        [else
         lod]))  

